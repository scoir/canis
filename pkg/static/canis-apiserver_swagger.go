package static

import (
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type staticFilesFile struct {
	data  string
	mime  string
	mtime time.Time
	// size is the size before compression. If 0, it means the data is uncompressed
	size int
	// hash is a sha256 hash of the file contents. Used for the Etag, and useful for caching
	hash string
}

var staticFiles = map[string]*staticFilesFile{
	"canis-apiserver.swagger.json": {
		data:  "\x1f\x8b\b\x00\x00\x00\x00\x00\x02\xff\xec[\xefo\xdb8\x93\xfe\x9e\xbfbNw@\x93[\x9f\x92f\x17\xfb!\x8b\x00\xe7m\xdcn\x16i\x128·\x17U\x90P\xd2\xc8\xe6\x96\"U\x92J\xea-\xf2\xbf\xbf\x18R\xb2e\xf9G\x1c\xa7-6}\xb3\xc0±H\x0e\x1f\xce<\xf3pH\xab_\xb6\x00\x02sǆC\xd4\xc1\x01\x04\xfb\xe1^Сg\\f*8\x00j\a\b,\xb7\x02\xa9\xfd\r\x93\xdc@7\u0379\x84\xee\xf9\xb1\xeb\v\x10ܢ6\\I\xea\xb1\x17\ue16f\x83-\x80{g'QҔ9\x9a\xe0\x00>\xf8\xbe\xac(\x04O\x98\xe5J\xee\xfee\x94\xa4\xbeW\xaeo\xa1UZ&k\xf6evd\xa6\x00w\xd9\x10\xa5\x9d>\x00\b\x86h\x1b_\x01\x02U\xa0v\xa6\x8eS\x02\xea\x16q}\u008d\xed\xd2\xd8j)\xae\xa7FS(i\xd0\xcc\x18\x00\b\xf6\xf7\xf6Z\x8f\x00\x82\x14M\xa2ya+\at\xc1\x94I\x82\xc6d\xa5\x80\xdaR\xd80\xef\x06\x99d\x849\x9b3\x06\x10\xfc\x8fƌ\xec\xfc\xf7n\x8a\x19\x97\x9c\xec\x9a]Vp\x83\xfa\x16\xf5\x04p\xbf2\x1d\xcc\x18\xb8o|\xbbo\xce\x19\xa4\x98\xb1R؇\xf1K(%~.0\xb1\x98\x02j\xad\xf4d\x19O]\x85.\xa5\xe59\xf6\xc8\xe8\n\xdc[\vV\x10\x14L\xb3\x1c-\xea)?\xfc\u007f\xad\xe5H\x96;\xaa\x1a˴m\x03\xe6n\x89\x9fJ\xd4\xe3v\x93\xc6O%\xd7H\xdcȘ0\xd8j\xb6\xe3\xa22\xab\xb9\x1c\xb6\agJ\xe7\x8c|\x1bpi\u007f\xfd%X\x16\x85%X\v6\xc4k\xc3\xff\xc6g\x82\xd7}~+\xa8\v\x99p\xd5`\x82e\xc36\a|6O\x87^m\xb5\x16\x13\x14ʬ\xa3\ao42\x8b\xcfJ\x11\x1a\x90_4a5oc\x95\x8e\x17\xf3vQK\x83\xb6V\x97\xf8\xb5\xe2\xe5ɵ\xc6J7\xe5\xfcV\xc3M\xf5θ\xfb\xc5}\x86<\xbdon\x92kf\xc5e\x91>\xb7\xach@~Ɋ\xd5YQ3cqfP\xa5\xf5\xb8\xccX\xa1睗\x1c]\x95\xa3\xad\xec\\\xaf\x84}\x87ϫ\x82\xad\xf1\xbe\xa4\xe5\xeaD\xf8.\t\xf9\xf5\n\xac\x14\x05Z\\\x83\xafG\xae㳢l\x03\xf2\vk\u007f\x04\xd6\xce\xca\xef\x9c?\x1fqyp\xe1\xc7>\xa3\xdb\x03\x8f\xf8\x85\xc7/\xd7\a?\xfc\xf5\xc1\x1aX\xea\xab\xcb\x1f\xf86\xe3yIT\x13\xf3\x8bH=\x83\xb3RE\xaf\xefvX\xf2@7?,=\xaft\x98\x00~Ʌ\xff\xe4\xe3\xd2\xf3\"m\x13\xf3\vo\u007f\xd4\x03\xd3\xee\x17\xff\xf9\xa4K\xe5\xe7E\xec&\xe6\x17b?p\x82\xaa\xc9\xf1r\xaf\xfc\xddk\xa5\xc9\xfb\x17\r\x14ӷ%\xdcEօe\xb6\x9cycbə/@Y\xe63\xd3\a\x17\x83n\u007fp|\xfa\xae\x99\xb6\xfd\xcb\xd3\xd3֣^\xbf\u007f\xd6o>\x18\xf4\xfa\xef\x8fO\xbb\x83\xdeQ\x8d\xfc\xaa\xb1!\xd6\xe915?\xa3:\xad\xcb\xf9\x05\xc0U\xfc\x17&\xd3C{Ph\x12\x1e\xcb[RB\x92ے\x96e\xd4j\xf2\xbf\"ң\xc71c\xf8Pbz\xedYs\xbd\xd9\xec(S\xa5\r\x8b\x05N\xed\x98e\x86\x98\xd6l\x96\xd2\x01\xb7\x98\x9by\xedYg\xcfh\xc20m֬`}\x93f\x8b\x15\xa5\x8c\x05O\xae\xd3\xe5\x1e\x89\x95\x12\xc8fO\xe7\x8dۇ\xbay\xab\r\xfa~\x05sz\xb7O\xa4O\xd5\u007f\r\x0f,\x98x@\x83\x17z\xe3L\xa4\x9bX]l\xec\x14\xef\x9ehl]O\x0ef\xbd\xf1\b\x15\xe9\x1e\x1d5\xc5\xe1\xf2\xfc\xa8;\xe85\x9f\x1c\xf5Nz\x83\xdeJ\xa9 \x1bK\x10Z\xaby\\Z|J\xa87\xcd\xf9M(R\xe3m1\xe4\x818̌\xdaP\xcc\xfb-\xdd>\xbd|\xff{oF\xb8\xcf~\xff\xb3\xf7f\xd0|\xd2\xed\xf7\xbb\xffj>\xf8\xfd\xec\xecd\xd6\xc8\xc9\xc9\x03*\xdf_\xae\xf1\x8b^j\xf9>\x8a\xbf\xda\xdf\vo\xa7\xfe\t\xc0\x16\xfdD\xb5\x1c\xd7*\x1bk/n\xb1\x91\xb9\x9fw\x9f\xe0\x1d\xd6\xda\u9ffe\x8e\xcd_\xaf<\x01\xee²\xf0\xb1%\xe1\x03\x80\xe7\xdf\xff|\x02\xe0D\x95\xf3\xfe]q\xf5\xbf\xfc\xe2\u007f\xa6\xe0i\xbf\x8b\xbbam\xf2\xd8w4\xee\x1f\xe3ï\x17\xf5o\xe3\xc4\xc5\\\xfa\xeaN\x9c?\x90\xac\xedŋ\xb9_M\xff\xd9u\xf8\xf4%\xf5Ǘ\xf0\xf5.\xfb\x1dX=)[6\x8a\tbz\xee\xaa\xea\xa3㣍%|ѻs\x9b\xd9\xd8l/)\xb4\xb2*.\xb3\xae\x1c?\xb5N\xbf.\xb5xLn\xce]']\xf6Ov5\x1aU\xea\x04\x81\xa8\av\xc4,\x94\x92\u007f*Q\x8c\x81\xa7(-\xcf8\x1a\xb0#\x04\xb2\r*s\u007f\x1bԜ\t\xfe7\xa6\x91tKJ\x94\x80\xb8\xcc2Ԑ\xa31l\x88!\fF\b\x82\x19\v\x06\x879J[\x0f\xbe쟼2P0;\x82\xbc4\x164\x16\x1a\rJ\x1bIj\xceJ!\xc6\xf0\xa9d\x82\xe6N=\xb2j\xa8ð\xcd\fp\x19\xc9\x1b2\xb1;Tj(0\xac\x1d\x1b\x1e\x95\xfe>\xeef\xc7#p\xc3\xcdH\x95\"\x85\x18\x81K`\x900\xa9$O\x98\x00\x12\xacHnc8\f; \x90\xa5\\\x0e!\n\xc2(\x00n@*\v,I\xb0\xb0\x98\ue111\x8c䱄B\xb3\xc4\xf2\x04;`\x91\xe5\x06JS2B\\hLT^pA\x93X\xe5\xf0\xc6\\2=\x06&\x84\x83n\xbc\x87\xed\b\xc7Qu\x0f\x06܂UP\x1a\a\x8d\xc6$JZ\xfc\xec\xbcՕ\xe3\x10\xfePwx\x8b\xbaCX\xc9w\x06\xeeF<\x19\xb9!v\x84\x91tz\x8ap3\xb2\xb6\xb8\xe9\xf8Os\xd3\x01\xa5A*\xf0\xad\x1dP\x12iݠ\x1c\x03\x1cb\x83\x16\xca\x02\x98\xc3\x16I\xcfn\x0f1g\x85\xf1\xdev3ZU\x87\x15\x1a\xa9\r\xcc@\xa6\x84Pw怜\xf3\xbfp\x9cM\xa7$\a\x16Z\xdd\xf2\x14\xd3\t*zȌ)sLC\x1aЕ\xf0\xc7`p\x0e\xefz\x03P\xb2\xa6\x87\xe7Ř\xa3H\x81\xc1\x87v\x88\xe9@p\xf5\xe1*\x92\x00\xb7L\x94\xces\x95\xa7\xfd\x06\xe4\xd6^\xfd\x9b\x1b`\xd2\xdf4\xfa\xf9\xa6\xff\xec\xc6\x00\xd3H\xa1Qw\x98\xd2\n\x13\x96\x10c\x95\xfaX\x16\xa0є\xc2\x1a\x88\x99\xc1\xb4\x82F\x13^\xf6O\x9c\xf5\x11\xbbu\xee\xcf\x1bqO}\xe0Y\r\x86\xfe\xbeU<\x05&\xc74֛v\xb4Ԙ)\x8d\x9d\xba'\x19`\x96\xc7\\p;\x06\x89\x98:\x9f\xc7\b.5\xf4-%\x1a\x10\x8cd\xc4\xe4\x10]\xabcT\bۗ\x06\xa1\xda\x01h!\x144\"\xbd\x8f\x1a\x93l\xe8\x80\xc7\x1a\xd9Gbwe!ܡ\x90\x9d*\x8b\a`G\xdc@V\xca\xc4S\x830T\xecOJ\xadQZ1\x06v˸`\xb1\x98\xf0Te\x19O8\x13\x95\x02\xc4e\x06\x1a\x052\x83\x1d`2%bWFJr!\xb1wJ\xa8\x18\x87\\J\x82s\xc7\xed(\x92\xd4\x12\xfa8\x93Ά\x89\xca]\xbe9\x95E\x03ʎ<5e\x9b\xe7\xb0M\x86G\b\x98\x17v\\qo\ar>\x1cY\x881\x92nv\x9a\x05x^\b$%r\xf1\aS`\xc23\x9e\x80\xc1\x9cI\xcb\x13\x13.\xd9^\x89d\x9b\x95A\xf1\xd8\xe2J\x19~OL\x8f\x11\x18Q\x99\xa7\re\x85\xb6\xb0V\x1a\xc8bu\x8b5\xf8*\xe0\xe1\x82\"\xbbq0\x9d\x99\xf1\xa6+\xc77Ne\x18\xa7$\x90\xc0ṱ&\x1e\xae\x98\xbd\xce\u007f&T\x155`\x91\xa4du\x82\xe1'\x89W\xee\x15\x93\xad\x81\"{^\x93F\xf0\xd8\xcd]i\x85\x01S\x16\x85\xd2N\x16\v\x96|\xdc-%}\x90\x18\xfat75\x03\xbdx\xab\fJ\xeb\x13\xa7\xa6\xb0\xa1\fei\xca=\x9fa\x88\x125\xb3\x0e\x81\x1d\xa9\xd4\xd4\xd8Ȧ\xf3\x1f!\xea}fD\x10x}\x00\xe74!\x91\xb8\x9a\x9bM\x96\xcf%\xbc\xf9\xe9'ן\x9c\xfbV)Ȕ\x82C\b\xc3\xf07\xff\x8c\x8c29\xae\xbe19\x0e\xc9\xdc[\xad\xf2\xedL\xa9\x9d\xeay\x18\x86\xfe\x0f\x9e\xc16u\xbatS\r\xd4vT\xee\xed\xed\xffJ]w\xe0\x8b\xef\xd3\xe8~߄\xba\xff\x00\xd4?\xd9-[\a+\x1c\xba\xbd\x86\f\xac\xc4\xc8\xcd\xf6[\xa5\xc2D0c\x9a\xe8\xbcY\xea\xe1Q4z\xfdր\r5\xee\x9f\x1f\xc0}>\xb6#%'Ƚ\xf9\xb7Jm\x87!\xe9V\xe5W\x8fz{g\xd6\xd1n\x01\xf3\xf8\xa9\xf9\xd8\xc3?\xea]\xbc\xe9\x1f\x9f\x0f\xce\xfa;\a\xf5\n\xa6\x11h\x8c\xaf,4\x80\xff\xf2\x00\xf0w\xaa\xc6\xec@\x1f\x1c\x82\x8ff\x11\x87o\x95\xfa\x12\x86\xe1}\xd5\xcc\xe4\xb8C\x1b\x13\xf5)\xbc\x94\xbfgڌ\x98\xa0550L\x16\xb1\xd0bm\x8eg-c\x972\x9f\x9as\x93\xb9\xc0\xba^\xffu\b\x92\x8bi\xf8\x1as\xb88Q\xdd\xe4\xd6V\xa7K\xbd\x8fC<\x86\xa2\x9d\xb8w\\\bj\xa8.\xc0H\xee#\xf9j\x81\xa2\xefRi\x17\xba\x06ڠ^Q\xfd0Q\vR\x12\xf2*=\xf0\x9e\x8d\xe4$[\xa5\x18\xd7\xf5\xce\\}8\xd9\xf0\x80e\x16\xfd^\xe0\xca\xceW\xbb\xaf\"YIE=\x85\xaf\xa2\xb0\x8af\x14dJ\x851\xd3\x0e\xdd\xe7\xddq\xf8w\x14\xf8\xf5\xf8\xe2\xc3\x17F\xcex\x14\xb8VG\x87H\xfeyqv\x1a\xc9\xc3\xc3\xc3C\xef-\xfa>-d\xfd\xfe\xa2\x88t\xe0\xe5\xd6\xd7)\xa5\xa9\xf4Q\xe3\xb0\x14LGr~\b5\xa78\x15\xcd\x0e`\x1ec\x9aN\xe5\xb3S\xa9\xaf\x8cdC\xe32\a\xf8\xe6\xff\t\xf2MU\"ND\xbe邰&\xf3AMUr6\xf1wZge\\`\x95\xb85\xb9\xcfQ\x1b%\xa7\x9c\xf1\xfb\x1ed\\\x1b{\xed<t\b\xaf\u007fk\xb5R\x1c\xea\xc6\xfd\x19%\x00\x98\x9a\x8a\x02\x87:\n\x0e \n\x16\xf1f\x16X\xe8\xa1DAgj\xc0\xc18e\xb97R\xee\xed\xfd\x9cx\b\xeeol\xf4$H\xcb;6 \x1egUY1\xeb}\xefGn\xe0\x0e\x85\xf8\xbf\x8fR\xddI\xc7\xdb\x113t\xb2(\x8dU9xz\xcc\x06\xb7\xe37\xcaV\xc4}\xf24\xa6\xa1\x90\xca!0\x1f\xd0H\xde8\xea\xd4\x11\x1d)\x91\xfap6fr\x87\x9a\x8a\tP\x9d<*\"Dҙ\x99\xc4\x1c\xb6\x89\xff\xf5R>,;<]}\xb8\xda9xJ\x9cf\xcd̈́ʭ\xc7\xdbx\x1d\xee\xbf\xde7QPy}\xf6\xa8<\xf3\x83\xfe\x13\xce\xca\xd82\xb0\xf6\xd5H\xa2ҥU\x1f\x97\x16\x87\xa8W\xdc~\xfd\xbc\xbf\xd8j\xe5\xfbM\x00\xa5h\x19\x17\xdf좦y7\xf1\x88\x1b\x9a*N\x17V#˟\x1c\xad\xa1.\x92\xebo\xe3y:/\\\xff\xe3\x82\xeaP-\xfe\xed\xf9\x19rb\x8b\xfe\xbf\xdf\xfaw\x00\x00\x00\xff\xff\xaej\bp}C\x00\x00",
		hash:  "bc4f48dec756b271a97fae71ef732971d907afc980703dc23d90ece910e615e3",
		mime:  "application/json",
		mtime: time.Unix(1597176781, 0),
		size:  17277,
	},
}

// NotFound is called when no asset is found.
// It defaults to http.NotFound but can be overwritten
var NotFound = http.NotFound

// ServeHTTP serves a request, attempting to reply with an embedded file.
func ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	path := strings.TrimPrefix(req.URL.Path, "/")
	f, ok := staticFiles[path]
	if !ok {
		if path != "" && !strings.HasSuffix(path, "/") {
			NotFound(rw, req)
			return
		}
		f, ok = staticFiles[path+"index.html"]
		if !ok {
			NotFound(rw, req)
			return
		}
	}
	header := rw.Header()
	if f.hash != "" {
		if hash := req.Header.Get("If-None-Match"); hash == f.hash {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("ETag", f.hash)
	}
	if !f.mtime.IsZero() {
		if t, err := time.Parse(http.TimeFormat, req.Header.Get("If-Modified-Since")); err == nil && f.mtime.Before(t.Add(1*time.Second)) {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("Last-Modified", f.mtime.UTC().Format(http.TimeFormat))
	}
	header.Set("Content-Type", f.mime)

	// Check if the asset is compressed in the binary
	if f.size == 0 {
		header.Set("Content-Length", strconv.Itoa(len(f.data)))
		io.WriteString(rw, f.data)
	} else {
		if header.Get("Content-Encoding") == "" && strings.Contains(req.Header.Get("Accept-Encoding"), "gzip") {
			header.Set("Content-Encoding", "gzip")
			header.Set("Content-Length", strconv.Itoa(len(f.data)))
			io.WriteString(rw, f.data)
		} else {
			header.Set("Content-Length", strconv.Itoa(f.size))
			reader, _ := gzip.NewReader(strings.NewReader(f.data))
			io.Copy(rw, reader)
			reader.Close()
		}
	}
}

// Server is simply ServeHTTP but wrapped in http.HandlerFunc so it can be passed into net/http functions directly.
var Server http.Handler = http.HandlerFunc(ServeHTTP)

// Open allows you to read an embedded file directly. It will return a decompressing Reader if the file is embedded in compressed format.
// You should close the Reader after you're done with it.
func Open(name string) (io.ReadCloser, error) {
	f, ok := staticFiles[name]
	if !ok {
		return nil, fmt.Errorf("Asset %s not found", name)
	}

	if f.size == 0 {
		return ioutil.NopCloser(strings.NewReader(f.data)), nil
	}
	return gzip.NewReader(strings.NewReader(f.data))
}

// ModTime returns the modification time of the original file.
// Useful for caching purposes
// Returns zero time if the file is not in the bundle
func ModTime(file string) (t time.Time) {
	if f, ok := staticFiles[file]; ok {
		t = f.mtime
	}
	return
}

// Hash returns the hex-encoded SHA256 hash of the original file
// Used for the Etag, and useful for caching
// Returns an empty string if the file is not in the bundle
func Hash(file string) (s string) {
	if f, ok := staticFiles[file]; ok {
		s = f.hash
	}
	return
}
