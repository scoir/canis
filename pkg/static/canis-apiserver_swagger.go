package static

import (
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type staticFilesFile struct {
	data  string
	mime  string
	mtime time.Time
	// size is the size before compression. If 0, it means the data is uncompressed
	size int
	// hash is a sha256 hash of the file contents. Used for the Etag, and useful for caching
	hash string
}

var staticFiles = map[string]*staticFilesFile{
	"canis-apiserver.swagger.json": {
		data:  "\x1f\x8b\b\x00\x00\x00\x00\x00\x02\xff\xec[]o\xdb8\xb3\xbeϯ\x98\xa3s\x80&g}\x944\xbb؋,\x02\x1co\xe3v\xb3H\x93\xc0q.^TABI#\x9b[\x89TIʩ\xb7\xc8\u007f\u007f1\xa4d\xcb\xf2G\x1c\xbb-\xd6}]\xa0\xb0͏\xe1Ùg\x1e~H\xf9\xb2\a\xe0\xe9G\xd6\xef\xa3\xf2N\xc0;\xf6\x8f\xbc\x16\x95q\x91H\xef\x04\xa8\x1e\xc03ܤH\xf5o\x98\xe0\x1a\xdaq\xc6\x05\xb4\xaf\xcfm[\x00o\x88Js)\xa8ő\u007f\xe4\xbf\xf6\xf6\x00\x9e\xac\x9dH\n]d\xa8\xbd\x13\xf8\xe0ڲ<Oy\xc4\f\x97\xe2\xf0/-\x05\xb5\xbd\xb3ms%\xe3\"Z\xb1-3\x03=\x01x\xc8\xfa(̤\x00\xc0룩\xfd\x04\xf0d\x8eʚ:\x8f\t\xa8\x9d\xc4\xfd\x05צM}˩ؖ\nu.\x85F=e\x00\xc0;>:j\x14\x01x1\xeaH\xf1ܔ\x0eh\x83.\xa2\b\xb5N\x8a\x14*K~ͼ\xed\xa4\xa3\x01fl\xc6\x18\x80\xf7?\n\x13\xb2\xf3߇1&\\p\xb2\xab\x0fY\xce5\xaa!\xaa1\xe0niڛ2\xf0T\xfb\xf5T\x1fӋ1aEj\x9e\xc7/\xa0\x10\xf89\xc7\xc8`\f\xa8\x94T\xe3il:\vU\b\xc33\xec\x90\xd1%\xb8\xf7\xe6\xcc\xc0˙b\x19\x1aT\x13~\xb8\u007f\x8d\xe9\b\x96Y\xaajÔi\x02\xe6v\x8a\x9f\nT\xa3f\x95\xc2O\x05WH\xdcHX\xaa\xb1QmFyiVq\xd1ovN\xa4\xca\x18\xf9\xd6\xe3\xc2\xfc\xfa\x8b\xb7(\n\v\xb0欏\xf7\x9a\xff\x8d[\x82\xd7~~+\xa8s\x99pWc\x82a\xfd&\a\\6O\xba\xde\xed5&\xe3\xe5R\xaf\xa2\ao\x142\x83[\xa5\b5\xc8;MX\xce\xdbPƣ\xf9\xbc\x9dWS\xa3\xadQ\x05~\xadx9r\xad0\xd3u9\xbfWsS\xb52\x1e~\xb1\x9f>\x8f\x9f\xea\x8b\xe4\x8aYq\x9b\xc7ۖ\x155Ȼ\xacX\x9e\x15\x153\xe6g\x06\xed\xb4^\x96\x19K\xf4\xbc\xb5\xcb\xd1gs\xf4\x9e\xc7O\x87\\\f\xb9a%\xd3^\x9a\xae\xef\xd0m\x11\xcf'F\xb6$k'\x88wI\xbbB\xd2\xde\u007f\x97\xa4\xfdFdo,E\xab\x9d\xd7*jo\v\xa1+\xbc;:/\xa7\xf3v\x10y|\x9a\x881E\x83+\xf0\xf5\xcc6\xdc*\xca\xd6 \xefX\xfb#\xb0vZ~g\xfc\xf9\x82\x9b\xb2\x1b\xd7w\x8b\xae\xca\x1c\xe2\x1d\x8fwwe?\xfc]\xd9\nX\xaa{\xfa\x1f\xf8\xean\xbb$\xaa\x8ey'R[p1P\xd2\xeb\xbb\xdd\f8\xa0\xeb\x1f\x96\xb6+\x1dƀw\xb9\xf0\x9f|\\\xda.\xd2\xd61\xefx\xfb\xa3\x1e\x98\x0e\xbf\xb8ύ\x9e\xa0l\x17\xb1\xeb\x98w\xc4~\xe6\x04U\x91c\xf7\x10\xe5\xbb\xef\x95\xc6/\x1b\xd5PL^\r\xb2\x17Y7\x86\x99b\xea\xf5\xa0\x05g>\x0fE\x91M\r\xef\xdd\xf4\xda\xdd\xde\xf9\xe5\xbbz\xdavo//\x1bE\x9dn\xf7\xaa[/\xe8u\xba\xef\xcf/۽\xceY\x85\xfc\xae\xb6 V\xe911?\xa5:\x8d'Qs\x80\xcb\xf0/\x8c&\x87v/W$<\x867\xa4\x84$\xb7!-\x8b\xa8U\xe7\u007fI\xa4\x17\xf7cZ\xf3\xbe\xc0\xf8ޱ\xe6~\xbd\xd1Q\xc4Ri\x16\xa68\xb1\xa3\x17\x19bJ\xb1iJ{\xdc`\xa6g\xb5g\x955\xa3\x0eC7Y\xb3\x84\xf5u\x9a\xcdW\x94\"Lyt\x1f/\xf6H(e\x8al\xfat^\xbb}\xa8\xaa\xf7\x9a\xa0\x9f\x960\xa73ܐ>e\xfb\x15<0g\xe0\x1eu\x9e덫4^\xc7\xea|c\x97\xf8\xb8\xa1\xb1U=ٛ\xf6\xc6\vT\xa4}vV\x17\x87\xdb\xeb\xb3v\xafS/9\xeb\\tz\x9d\xa5RA6\x16 4F\xf1\xb00\xb8I\xa8\xd7\xcd\xf9u(R\xe1m0\xe4\x998L\xf5ZS̻\rݾ\xbc}\xff{gJ\xb8\xaf~\xff\xb3\xf3\xa6W/iw\xbb\xed\u007f\xd5\v~\xbf\xba\xba\x986rq\xf1\x8c\xcaw\x17k\xfc\xbc7\xb8\xbe\x8f\xe2/\xf7\xf7\xdc۩\u007f\x02\xb0y\x8f\xa8\x16\xe3Zfc\xe5\xc9\xcd72\xf3xw\x03\xef\xb0\xc6J\xff\xf5ul\xf6ze\x03\xb8s\xb7\x85/\xdd\x12>\x03x\xce\xeb \x9b\xd0o\xde;5\x9b\xd0p\xf6]\xec\r\xd0E\xb2\x98\r\xff\x92'\x13\x8b\x9fKL\xedǚ\xefů\xb9uz\xe9\xfbRO/\xf1\xe1\xd7#\xe5\xb7q\xe2|\xaa\u007fu'Ξ\x97V\xf6\xe2\xcd\xccC\xdd\u007f\xf61a\xf2\a#/?aT\x9b\x80\xef\xc0\xea\xf1\xaej\xad\x98 \xc6\xd7v\xd3\u007fv~\xb6\xf6\n3\xef=\xd6\xf5l\xac\xb7\xd4\xe5J\x1a\x19\x16I[\x8c6=F\xdc\x17*}In\xce\xdcv\xddv/\x0e\x15jY\xa8\b\x81\xa8\af\xc0\f\x14\x82\u007f*0\x1d\x01\x8fQ\x18\x9ep\xd4`\x06\bd\x1bdb\xbfkT\x9c\xa5\xfco\x8c\x03a\xa7\x14\xc9\x14\xc2\"IPA\x86Z\xb3>\xfa\xd0\x1b \xa4L\x1b\xd0\xd8\xcfP\x98\xaa\xf3m\xf7╆\x9c\x99\x01d\x856\xa00W\xa8Q\x98@PuR\xa4\xe9\b>\x15,\xa5\xb1c\x87\xac\xecj1\xec3\r\\\x04\xe2\x81L\x1c\xf6\xa5\xec\xa7\xe8W\x8e\xf5\xcf\nw]\xf8p\xe0\x10\xd8\xeez \x8b4\x86\x10\x81\v`\x101!\x05\x8fX\n$X\x81\xd8G\xbf\xef\xb7 E\x16sч\xc0\xf3\x03\x0f\xb8\x06!\r\xb0(\xc2\xdc`|\xe0\a\"\x10\xe7\x02r\xc5\"\xc3#l\x81A\x96i(t\xc1\bq\xae0\x92Y\xceS\x1a\xc4H\x8b7䂩\x11\xb04\xb5е\xf3\xb0\x19\xe0((\xaf\xe9\x80\x1b0\x12\nm\xa1Q\x9fH\n\x83\x9f\xad\xb7\xdab\xe4\xc3\x1f\xf2\x11\x87\xa8Z\x84\x95|\xa7\xe1q\xc0\xa3\x81\xedb\x06\x18\b\xab\xa7\b\x0f\x03c\xf2\x87\x96\xfb\xd4\x0f-\x90\n\x84\x04W\xdb\x02)\x90\xe6\r\xd22\xc0\"\xd6h\xa0ȁYl\x81p\xecv\x103\x96k\xe7m;\xa2\x91UX\xa1\x96\xda\xc04$2M\xe5\xa3>!\xe7\xfc/\x9c'\x93!Ɂ\xb9\x92C\x1ec<FE\x85L\xeb\"\xc3ا\x0em\x01\u007f\xf4z\xd7\xf0\xae\xd3\x03)*z8^\x8c8\xa610\xf8\xd0\f1\x9dW\xee>\xdc\x05\x02`\xc8\xd2\xc2z\xae\xf4\xb4[\x80\xec\xdc˿\u007f\x03&\xdcE\xa8\x1bo\xf2'p\x1a\x98B\n\x8d|Ęf\x18\xb1\x88\x18+\xe5\xc7\"\a\x85\xbaH\x8d\x86\x90i\x8cKh4\xe0m\xf7\xc2Z\x1f\xb0\xa1u\u007fV\x8b{\xec\x02\xcf*0\xf4}(y\fL\x8c\xa8\xaf3mi\xa90\x91\n[UK2\xc0\f\x0fy\xca\xcd\b\x04bl}\x1e\"\xd8\xd4PCJ4 \x18р\x89>\xdaZ\xcb(\x1f\xf6o5B\xb9\x02\xd0D(hDz\x175&X\xdf\x02\x0f\x15\xb2\x8f\xc4\xee҂\u007f@!\xbb\x94\x06O\xc0\f\xb8\x86\xa4\x10\x91\xa3\x06a(\xd9\x1f\x15J\xa10\xe9\bؐ\xf1\x94\x85阧2Ix\xc4YZ*@X$\xa00E\xa6\xb1\x05L\xc4D\xec\xd2HA.$\xf6N\b\x15b\x9f\vAp\x1e\xb9\x19\x04\x82j|\x17g\xd2Y?\x92\x99\xcd7\xab\xb2\xa8A\x9a\x81\xa3\xa6h\xf2\x1c\xf6\xc9\xf0\x00\x01\xb3܌J\xee\x1d@\xc6\xfb\x03\x03!\x06\u008eN\xa3\x00\xcf\xf2\x14I\x89l\xfcA\xe7\x18\xf1\x84G\xa01c\xc2\xf0H\xfb\v\x96W\"\xd9z۠pdp\xa9\f\xbf'\xa6\x87\b\x8c\xa8\xcc㚲BSXK\rd\xa1\x1cb\x05\xbe\f\xb8?g\x93];7O\x8d\xf8\xd0\x16\xa3\a\xab2\x8cS\x12\b`*\xe4F\x11\x0f\x97\x8c^\xe5?Ke\x195`\x81\xa0d\xb5\x82\xe1\x06\t\x97\xae\x15㥁\"{]\x91&\xe5\xa1\x1d\xbb\xd4\n\r\xba\xc8s\xa9\xac,\xe6,\xfaxX\b\xfa 1t\xe9\xae+\x06:\xf1\x96\t\x14\xc6%NEaM\x19\xca\xe2\x98;>C\x1f\x05*f,\x023\x90\xb1\xae\xb0\x91M\xeb?B\xd4\xf9̈ \xf0\xfa\x04\xaei@\"q96\x1bO\x9f\vx\xf3\xd3O\xb6=9\xf7\xad\x94\x90H\t\xa7\xe0\xfb\xfeo\xae\x8c\x8c21*\u007f11\xf2\xc9\xdc[%\xb3\xfdDʃ\xb2\xdc\xf7}\xf7\x85'\xb0O\x8dn\xedP=\xb9\x1f\x14GGǿR\xd3\x03\xf8\xe2\xdaԚ?ա\x1e?\x03\xf5O6d\xab`\x85S\xbb\u0590\x81\xa5\x18\xb9\xde\u007f+\xa5\x1f\xa5L\xeb::g\x96Z8\x14\xb5V\xbf\xd5`C\x85\xfb\xe7gp_\x8f\xcc@\x8a1rg\xfe\xad\x94\xfb\xbeO\xbaU\xfaա\xde?\x98v\xb4\x9d\xc0,~\xaa>w\xf0\xcf:7o\xba\xe7\u05fd\xab\xee\xc1I5\x83I\x04j\xfdK\v5\xe0\xbf<\x03\xfc\x9d\xac0[\xd0'\xa7\u0899\x87\xfe[)\xbf\xf8\xbe\xffTV31j\xd1\xc2Dmr'\xe5\xef\x99\xd2\x03\x96Ҝj\x18Ɠ\x98k\xb12Ǔ\x86\xb1[\x91M\xcc\xd9\xc1l`m\xab\xff:\x05\xc1\xd3I\xf8jc\xd88Ѿ\xc9έJ\x97j\x1d\x87p\x04y3q\x1fy\x9aREy?Gr\x1f\x88Ws\x14\xfd\x90\xb6v\xbe\xad\xa0\x05\xea\x15\xed\x1f\xc6jAJB^\xa5\x02\xe7\xd9@\x8c\xb3U\xa4\xa3j\xbf3\xb3?\x1c/x\xc0\x12\x83n-\xb0\xdb\xceW\x87\xaf\x02QJE5\x84\xdbEa\x19\xcd\xc0K\xa4\xf4C\xa6,\xbaχ#\xff\xef\xc0s\xf3q\x9b\x0f\xb71\xb2\xc6\x03\xcf\xd6Z:\x04\xe2ϛ\xab\xcb@\x9c\x9e\x9e\x9e:o\xd1\xef\xc9F֭/\x92H\aNn\xdd>\xa5Х>*\xec\x17)S\x81\x98\xedB\xd51ND\xb3\x05\x98\x85\x18\xc7\x13\xf9l\x95\xea+\x02QӸ\xc4\x02~\xf8\u007f\x82\xfcPn\x11\xc7\"_w\x81_\x91\xf9\xa4\xa2*9\x9b\xf8;\xd9g%<\xc52q+r_\xa3\xd2RL8\xe3\xd6=H\xb8\xd2\xe6\xdez\xe8\x14^\xff֨\xa58T\x95\xc7SJ\x0001\x15x\x16u\xe0\x9d@\xe0\xcd\xe3\xcd40\xdfA\t\xbc\xd6Ā\x85q\xc92g\xa48:\xfa9r\x10\xecw\xac\xb5$H\x8b\x1b\xd6 \x9e'\xe5\xb6b\xda\xfbΏ\\\xc3#\xa6\xe9\xff}\x14\xf2QX\xde\x0e\x98\xa6\x93E\xa1\x8d\xcc\xc0\xd1c:\xb8-\xb7P6\"\ue4a76\f\x85T\U00101e40\x06\xe2\xc1R\xa7\x8a\xe8@\xa6\xb1\vgm${\xa8)\x99\x00\xe5ɣ$B \xac\x99q\xcca\x9f\xf8_M\xe5â\xc3\xd3݇\xbb\x83\x93M\xe24mn*Tv>\xce\xc6k\xff\xf8\xf5\xb1\x0e\xbc\xd2\xeb\xd3G\xe5\xa9\xf7\r68+c\xc3\xc0\xcaW#\x91\x8c\x17\xee\xfa\xb80\xd8G\xb5\xe4\xf6\xeb\xe7\xe3\xf9VK߯\x03(F\xc3x\xfa\xcd.j\xeaw\x13/\xb8\xa1)\xe3tc\x14\xb2l\xe3h\xf5U\x1e\xdd\u007f\x1b\xcf\xd3y\xe1\xfe\x1f\x17T\x8bj\xfe\xa3\xf1-\xe4\xc4\x1e\xfd\u007f\xda\xfbw\x00\x00\x00\xff\xffh\xb91*\tG\x00\x00",
		hash:  "c89e1104574713f5d4ccc634e5a8bbbfbb31c8051a0d4f8784468cb93cecd87e",
		mime:  "application/json",
		mtime: time.Unix(1599169975, 0),
		size:  18185,
	},
}

// NotFound is called when no asset is found.
// It defaults to http.NotFound but can be overwritten
var NotFound = http.NotFound

// ServeHTTP serves a request, attempting to reply with an embedded file.
func ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	path := strings.TrimPrefix(req.URL.Path, "/")
	f, ok := staticFiles[path]
	if !ok {
		if path != "" && !strings.HasSuffix(path, "/") {
			NotFound(rw, req)
			return
		}
		f, ok = staticFiles[path+"index.html"]
		if !ok {
			NotFound(rw, req)
			return
		}
	}
	header := rw.Header()
	if f.hash != "" {
		if hash := req.Header.Get("If-None-Match"); hash == f.hash {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("ETag", f.hash)
	}
	if !f.mtime.IsZero() {
		if t, err := time.Parse(http.TimeFormat, req.Header.Get("If-Modified-Since")); err == nil && f.mtime.Before(t.Add(1*time.Second)) {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("Last-Modified", f.mtime.UTC().Format(http.TimeFormat))
	}
	header.Set("Content-Type", f.mime)

	// Check if the asset is compressed in the binary
	if f.size == 0 {
		header.Set("Content-Length", strconv.Itoa(len(f.data)))
		io.WriteString(rw, f.data)
	} else {
		if header.Get("Content-Encoding") == "" && strings.Contains(req.Header.Get("Accept-Encoding"), "gzip") {
			header.Set("Content-Encoding", "gzip")
			header.Set("Content-Length", strconv.Itoa(len(f.data)))
			io.WriteString(rw, f.data)
		} else {
			header.Set("Content-Length", strconv.Itoa(f.size))
			reader, _ := gzip.NewReader(strings.NewReader(f.data))
			io.Copy(rw, reader)
			reader.Close()
		}
	}
}

// Server is simply ServeHTTP but wrapped in http.HandlerFunc so it can be passed into net/http functions directly.
var Server http.Handler = http.HandlerFunc(ServeHTTP)

// Open allows you to read an embedded file directly. It will return a decompressing Reader if the file is embedded in compressed format.
// You should close the Reader after you're done with it.
func Open(name string) (io.ReadCloser, error) {
	f, ok := staticFiles[name]
	if !ok {
		return nil, fmt.Errorf("Asset %s not found", name)
	}

	if f.size == 0 {
		return ioutil.NopCloser(strings.NewReader(f.data)), nil
	}
	return gzip.NewReader(strings.NewReader(f.data))
}

// ModTime returns the modification time of the original file.
// Useful for caching purposes
// Returns zero time if the file is not in the bundle
func ModTime(file string) (t time.Time) {
	if f, ok := staticFiles[file]; ok {
		t = f.mtime
	}
	return
}

// Hash returns the hex-encoded SHA256 hash of the original file
// Used for the Etag, and useful for caching
// Returns an empty string if the file is not in the bundle
func Hash(file string) (s string) {
	if f, ok := staticFiles[file]; ok {
		s = f.hash
	}
	return
}
