package static

import (
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type staticFilesFile struct {
	data  string
	mime  string
	mtime time.Time
	// size is the size before compression. If 0, it means the data is uncompressed
	size int
	// hash is a sha256 hash of the file contents. Used for the Etag, and useful for caching
	hash string
}

var staticFiles = map[string]*staticFilesFile{
	"steward_agent.swagger.json": {
		data:  "\x1f\x8b\b\x00\x00\x00\x00\x00\x02\xff\xec\\Qo\xdb8\x12~ϯ\x98\xd3\x1d\xd0\xe4\xd6'\xa7\xd9\xc5>d\x11\xe0\xb2m\xda\xcd\"M\x03\xc7y8TABI#\x8b[\x89TI*\xa9\xb7\xc8\u007f?\f)ٲ\xac8v\xd2\xf6\xd69\x17(l\x8b\xe4\xf0\xe3\xcc7\xc3\xe1Hʗ-\x00O߲\xd1\b\x95\xb7\x0fޞ\xbf\xeb\xf5\xe8\x1a\x17\x89\xf4\xf6\x81\xda\x01<\xc3M\x86\xd4\xfe\x8a\t\xae\xe10ι\x80óc\xdb\x17\xc0\xbbA\xa5\xb9\x14\xd4c\xd7\xdf\xf5_z[\x00wVN$\x85.s\xd4\xde>|p}YQd<b\x86K\xd1\xffCKA}/m\xdfBɸ\x8c\x96\xec\xcbL\xaa\xa7\x00\xfbl\x84\xc2L/\x00x#4\x8d\x9f\x00\x9e,PYQ\xc71\x01\xb5\x8b\xb8:\xe1\xda\x1c\xd2\xd8j)\xb6\xa7B]H\xa1Q\xcf\b\x00\xf0\xf6vw[\x97\x00\xbc\x18u\xa4xa*\x05\x1c\x82.\xa3\b\xb5N\xca\fjI~C\xbc\x1d\xa4\xa3\x14s6'\f\xc0\xfb\x87\u0084\xe4\xfc\xbd\x1fc\xc2\x05'\xb9\xba\xaf\r\xde2\x15O\xe0\x0e*\xc1\xde\xcc\xf0\xbbƯ\xbb\xe6\x8c^\x8c\t+3\xf30z\x01\xa5\xc0\xcf\x05F\x06c@\xa5\xa4\x9a,\xe2\xa9kP\xa50<\xc7#\x12\xba\x00\xf7V\xc7\n\xbc\x82)\x96\xa3A5e\x87\xfb\xd7Z\x8e`\xb9%\xaa6L\x996`n\x97\xf8\xa9D5n7)\xfcTr\x85Č\x84e\x1a[\xcdf\\Tb\x15\x17\xa3\xf6\xe0D\xaa\x9c\x91n=.\xcc\xcf?y\xf7Y\xe1\x1e\xac\x05\x1b\xe1\x95\xe6\u007f\xe2\x9aൟ\xdf\nj'\x13.\x1bL0l\xd4\xe6\x80\xf3\xe5\xe9\xd0˭\xd6b\xbcB\xeae\xa2\xc1+\x85\xcc\xe0\x1aŃ\x06\xe0MDX\xcc\xdaP\xc6\xe3n\xd6v\xb54HkT\x89_\xc7Z\x8eXK\xac\xf3\xb1|\xdfj(\xa9\xde\x13\xfb_\xec\xa7\xcf\xe3\xbb\xe6\xf6\xb8\xa4G\\\x14\xf1zyD\x03\xf0\xc6#\x16{D͋n\xaf\xa0\fk5\xafX\x10\xc9{\x1b\xff|\xc0?\xafx|\xd7\xe7\xe2\x86\x1bV\xf1l\xc5L\xf6-\x9a\xe3\xc9\xf07R\xad\x91\xcfZ\xa8ǂ\xd7\xe87\x8e\xbb\x84\xe3^}\x17\xc7\xfdF\x94omFK3|\x8dH]\xa3ݐy1\x99׃Ɠ\x93D\x8c\x19\x1a\\\x82\xad\xafm\xc75\"l\x03\xf0\x86\xb3ρ\xb3\xf7\x86\xde~\xc6J\x11\xa5\x8f8\x0e\x9c\u0601\xebT0\x9b\x02ސ\xfay\x93Z\xa7\xa5\x89\xe5\xadx\x04\xadϫ\xa1kD\xec\x19\xc8\x1bj??j\xcf\xe9s\x85;\x1a\xe7n\xec\xda\xdc\xd2px7,\xde\xdc\xd3x\xf6\xf74\x96\xc0R\xdfM}ƷX\xd6)@5\x11oB\xd4_\xbe\x88[Q\xeb\xbbUq\x1d\xccǗ\xb4\xd6\xc9\x15&p7~\xf0\xff\\\xd4Z'\xca6\x11oX\xfb\\\x8fI\xfd/\xee\xf3Iw\xb9\u05c9\xd6M\xc4\x1bZ?pn\xaa\xa9\xb1\xb9\xd1\xfd\x9ds\xa4\xc9c\xa0\r\fӇ6m\xe9\xea\xdc0S\xce<\xb8y\xcf9\xcfCQ\xe63\xd3{\xe7\xc3\xc3\xc1\xf0\xf8\xf4m\xd3e\a\x17\xa7\xa7\xadKG\x83\xc1\xfbA\xf3\xc2\xf0h\xf0\xee\xf8\xf4px\xf4\xbaF~\xd9\xd8\nk瘊\x9f\x898\x85\x92F\x86er(\xc6]\xa8e\xf8\aF\xd3S:u/P\x19ފ!\xb6\xffU\xa9\xb2vdYpʝ\x0f0\x17\x83\x93\xbeB-K\x15!\x10\xbf\xc0\xa4\xcc@)\xf8\xa7\x12\xb31\xf0\x18\x85\xe1\tG\r&E \xd9 \x13\xfb]\xa3\xe2,\xe3\u007fb\x1c\b\xbb\xa4Hf\x10\x96I\x82\nrԚ\x8dЇa\x8a\x901m@\xe3(Ga\xea\xc1\x17\x83\x93\x17\x1a\xc8q /\xb5\x01\x85\x85B\x8d\xc2\x04\x82\x9a\x932\xcb\xc6\xf0\xa9d\x19\xcd\x1d;d\xd5P\x8ba\x9bi\xe0\"\x10\xd7$\xa2?\x92r\x94\xa1_+\xd6\u007f]\xba\b}\xbd\xe3\x10\xd8\xe1:\x95e\x16C\x88\xc0\x050\x88\x98\x90\x82G,\x03:\xf8\ab\x1b\xfd\x91߃\fY\xcc\xc5\b\x02\xcf\x0f<\xe0\x1a\x844\xc0\xa2\b\v\x83\xf1\x8e\x1f\x88@\x1c\v(\x14\x8b\f\x8f\xb0\a\x06Y\xae\xa1\xd4%#ą\xc2H\xe6\x05\xcfh\x12#-ސ\v\xa6\xc6\xc0\xb2\xccB\xd7N\xc3&\xc5qP\xc5F\xe0\x06\x8c\x84R[h4&\x92\xc2\xe0g\xab\xadC1\xf6\xe17y\x8b7\xa8z\x84\x95t\xa7\xe16\xe5Qj\x87\x98\x14\x03a\xdd\x18\xe1:5\xa6\xb8\xee\xb9O}\xdd\x03\xa9@Hp\xad=\x90\x02i\xdd -\x03,b\x8d\x06\xca\x02\x98\xc5\x16\b\x8d\xea\x06\x95\x83\x98\xb3B;m\xdb\x19\x8d\xac\xcd\n\rg\x04\xa6!\x91Y&o\xf5>)\xe7\x9fp\x9cL\xa7$\x05\x16J\xde\xf0\x18\xe3\t*\xbaȴ.s\x8c}\x1ap(\xe0\xb7\xe1\xf0\f\xde\x1e\rA\x8a\x9a\x1e\x8e\x17c\x8eY\f\f>\xb4M<\x1c\x17x\xf9\xe12\x10\x007,+\xad\xe6*M\xbbB\x8e]{\xf5@80\xe1v\x1f7\xdf\xf4\x99p\rL!\x99F\xdebL+\x8cXD\x8c\x95\xf2cY\xd0VUfFC\xc84\xc6\x154\x9a\xf0bpb\xa5\xa7\xecƪ?o\xd8=v\x86g5\x18\xfa~#y\fL\x8ci\xac\x13mi\xa90\x91\n{uO\x12\xc0\f\x0fy\xc6\xcd\x18\x04blu\x1e\"X\xd7P7\xe4h@0\xa2\x94\x89\x11\xdaV\xcb(\x1f\xb6/4BU\xf5\xa1\x85\x90ш\xf4\xcejL\xb0\x91\x05\x1e*d\x1f\x89ݕ\x04\u007f\x87Lv*\r\xee\x83I\xb9\x86\xa4\x14\x91\xa3\x06a\xa8\xd8\x1f\x95J\xa10\xd9\x18\xd8\r\xe3\x19\v\xb3\tOe\x92\xf0\x88\xb3\xac\x8a\x00a\x99\x80\xc2\f\x99\xc6\x1e0\x11\x13\xb1+!%\xa9\x90\xd8;%T\x88#.\x04\xc1\xb9\xe5&\r\x04\xb5\xf8\xceά\xe0ڏdn\xfd\xcd\xee5\xa8A\x9a\xd4QS\xb4y\x0e\xdb$8E\xc0\xbc0\xe3\x8a{;\x90\xf3Qj \xc4@\xd8\xd9i\x16\xe0y\x91!E\"k\u007f\xd0\x05F<\xe1\x11h̙0<Ҿי2X\x92\xad\x12j\xa7\xe5\xc4plpa\x18~GL\x0f\x11\x18Q\x99Ǎ\xc8\n\xed\xc0Z\xc5@\x16\xca\x1b\xac\xc1W\x06o\x02\xef8\x9f\xcd\xccx}(\xc6\xd76\xca0NN \x80\xa9\x90\x1bE<\\0{\xed\xff,\x93\x95Հ\x05\x82\x9c\xd5\x06\f7I\xb8p\xaf\x98l\rdٳ\x9a4\x19\x0f\xed\xdcU\xacРˢ\x90ʆłE\x1f\xfb\xa5\xa0\x0f\n\x86\xce\xddu\xcd@\x17\xbce\x02\xa5q\x8eSSX\x93\x87\xb28\xe6\x8e\xcf0BAy\xbbE`R\x19\xeb\x1a\x1bɴ\xfa#DG\x9f\x19\x11\x04^\xee\xc3\x19MH$\xae\xe6f\x93\xe5s\x01\xaf~\xf8\xc1\xf6'徑\x12\x12)\xe1\x00|\xdf\xff\xc5]#\xa1L\x8c\xab_L\x8c}\x12\xf7F\xc9|;\x91r\xa7\xba\xee\xfb\xbe\xfb\xc2\x13ئN\x17v\xaa\xa1\xdc\x0e\xca\xddݽ\x9f\xa9\xeb\x0e|q}\x1a\xdd\xef\x9aP\xf7\x1e\x80\xfa;\xbba\xcb`\x85\x03\xbbא\x80\x85\x18\xb9\xde~#\xa5\x1feL\xeb&:'\x96z8\x14\x8d^\xbf4`C\x8d\xfb\xc7\ap\x9f\x8dM*\xc5\x04\xb9\x13\xffF\xcamߧ\xb8U\xe9ա\xdeޙU\xb4]\xc0<~j>v\xf0_\x1f\x9d\xbf\x1a\x1c\x9f\r\xdf\x0fv\xf6\xeb\x15L-\xd0\x18_Ih\x00\xff\xe9\x01\xe0oe\x8dق\xde?\x00g\xcd\"\xf4\xdfH\xf9\xc5\xf7\xfd\xbb\xaa\x99\x89q\x8f6&\xeaS\xb8P\xfe\x8e)\x9d\xb2\x8c\xd6\xd4\xc00YD\xa7\xc4Z\x1cOZ\xc2.D>\x15g'\xb3\x86\xb5\xbd\xfev\x00\x82gS\xf35\xe6\xb0v\xa2\xbcɮ\xadv\x97z\x1f\x87p\fE\xdbqoy\x96QC\x95\xfcR\xb8\x0fċ\x8e\x88ާ\xd4η\r\xb4A\xbd\xa0\xfca\x12-(\x92\x90V\xe9\x82\xd3l &\xde*\xb2q\x9d\xef\xcc凓\r\x0fXb\xd0\xed\x056\xed|\xd1\u007f\x11\x88*T\xd4S\xb8,\n+k\x06^\"\xa5\x1f2e\xd1}\xee\x8f\xfd?\x03ϭ\xc7%\x1f.1\xb2\xc2\x03϶Z:\x04\xe2\xf7\xf3\xf7\xa7\x818888pڢ\xdf\xd3D\xd6\xed/\x92H\a.ܺ<\xa5\xd4U|T8*3\xa6\x021?\x84\x9ac\x9c\x06\xcd\x1e`\x1eb\x1cO\xc3g\xaf\x8a\xbe\"\x10\x8d\x18\x97X\xc0\xd7\xff&\xc8\xd7U\x8a8\t\xf2M\x15\xf85\x99\xf7k\xaa\x92\xb2\x89\xbf\xd3<+\xe1\x19V\x8e[\x93\xfb\f\x95\x96b\xca\x19\xb7\xefA\u00956WVC\a\xf0\xf2\x97V+١nܛ\x89\x04t\u00ad;\a\x9eE\x1dx\xfb\x10x]\xbc\x99\x05\xe6;(\x81כ\n\xb00NY\ue114\xbb\xbb?F\x0e\x82\xfd\x8e\x8d\x9e\x04\xe9\xfe\x8e\r\x88\xc7I\x95V\xccj\xdf\xe9\x91k\xb8\xc5,\xfb\xd7G!o\x85\xe5m\xca4\x9d,Jmd\x0e\x8e\x1e\xb3\xc6\xed\xb9\x8d\xb2eq\xe7<\x8diȤb\x04\xcc\x194\x10ז:\xb5ES\x99\xc5Μ\x8d\x99졦b\x02T'\x8f\x8a\b\x81\xb0b&6\x87m\xe2\u007f\xbd\x94\x0f\xf7\x1d\x9e.?\\\xee\xec?\xc5N\xb3\xe2fLe\xd7\xe3d\xbc\xf4\xf7^\xee\xe9\xc0\xab\xb4>{T\x9e)\xf2<ᬌ-\x01\v\x8b0ʹ/\x92\xf1\xbdY\x1f\x17\x06G\xa8\xeeK\xfb\xb80?\xeeuK\xadt\xff\x18@1\x1a\xc63}\xdfP\xa6\x14\x9b\xad\x00y\xdc`\xae\xe7Ku\xdd\xe5\x9dfm\xa2\xbb\x8c\xd6YD\x9dy\xfd\xe1\tv\xe2\xf1ctR\xd5\xc5V\x1eǴ\xe6#\x81\xf1\x95+\x82]=nv\x14\xb1T\x9aNES9_\xc1>\xcb\x14\xc0\x9b0t\xbb\f\xb6\xc0\xcaͺ\xd9\n\x96\xedz\xc1\xe2\tƶ\xc5\xcae\x15\xbe\x10\x9c1\x8a\x87\xa5y\x12\x9aǒ\xa8계\xd6\xdbh\x874r\xc5\x15\x0egg[\xa9\xd49hU5O/\xde\xfdz4S\xd6|\xff\xeb\xefG\xaf\x86\xcd+\x87\x83\xc1\xe1\u007f\x9a\x17~}\xff\xfedV\xc8\xc9\xc9\x035\xd0\xc1\\\x05t\xc1\xbb\xa7\xdf'x,\xd2u\xe7\xd3\x1a\xff{X]\x0f\xd7ߏ\xea~\tK/\xacK\xc4\xdc+)O\xd0\vkm\x16+\xbf]\xb7P]\xf3\x0f\x1a<\x01j\xe7M\x92\xd5n\x90,\x04\xdb\xf5\x8c\xf9S\xe0~ӭ`\xfe/H<\x01j$\xcby\x12,WVk=\xa57\xb3\xb1\xb7\xff\x96\xc7W͑\xee{\xd7\xf3ny\xfd}=j~\x1b\x05v\x13\xfe++p\xfe\x1e\xe2\x92\x1a<\x9f{\xb0\xf9\xaf\x9dgN\xff\xb8\xcd\xea)j\xbd\xf1\u007fs6Or\xa8Gأ\xf3M\x82\xd5v\x96\xae\xb7\xee\x1f#a\xc5\xedm\x8b\xfe\xdfm\xfd7\x00\x00\xff\xff\x8a\xb6Eo\xc6H\x00\x00",
		hash:  "f705910ea53da16f4324cb9556b3b1da349114b59b67b9303cdefd98b5564d02",
		mime:  "application/json",
		mtime: time.Unix(1594243463, 0),
		size:  18630,
	},
}

// NotFound is called when no asset is found.
// It defaults to http.NotFound but can be overwritten
var NotFound = http.NotFound

// ServeHTTP serves a request, attempting to reply with an embedded file.
func ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	path := strings.TrimPrefix(req.URL.Path, "/")
	f, ok := staticFiles[path]
	if !ok {
		if path != "" && !strings.HasSuffix(path, "/") {
			NotFound(rw, req)
			return
		}
		f, ok = staticFiles[path+"index.html"]
		if !ok {
			NotFound(rw, req)
			return
		}
	}
	header := rw.Header()
	if f.hash != "" {
		if hash := req.Header.Get("If-None-Match"); hash == f.hash {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("ETag", f.hash)
	}
	if !f.mtime.IsZero() {
		if t, err := time.Parse(http.TimeFormat, req.Header.Get("If-Modified-Since")); err == nil && f.mtime.Before(t.Add(1*time.Second)) {
			rw.WriteHeader(http.StatusNotModified)
			return
		}
		header.Set("Last-Modified", f.mtime.UTC().Format(http.TimeFormat))
	}
	header.Set("Content-Type", f.mime)

	// Check if the asset is compressed in the binary
	if f.size == 0 {
		header.Set("Content-Length", strconv.Itoa(len(f.data)))
		io.WriteString(rw, f.data)
	} else {
		if header.Get("Content-Encoding") == "" && strings.Contains(req.Header.Get("Accept-Encoding"), "gzip") {
			header.Set("Content-Encoding", "gzip")
			header.Set("Content-Length", strconv.Itoa(len(f.data)))
			io.WriteString(rw, f.data)
		} else {
			header.Set("Content-Length", strconv.Itoa(f.size))
			reader, _ := gzip.NewReader(strings.NewReader(f.data))
			io.Copy(rw, reader)
			reader.Close()
		}
	}
}

// Server is simply ServeHTTP but wrapped in http.HandlerFunc so it can be passed into net/http functions directly.
var Server http.Handler = http.HandlerFunc(ServeHTTP)

// Open allows you to read an embedded file directly. It will return a decompressing Reader if the file is embedded in compressed format.
// You should close the Reader after you're done with it.
func Open(name string) (io.ReadCloser, error) {
	f, ok := staticFiles[name]
	if !ok {
		return nil, fmt.Errorf("Asset %s not found", name)
	}

	if f.size == 0 {
		return ioutil.NopCloser(strings.NewReader(f.data)), nil
	}
	return gzip.NewReader(strings.NewReader(f.data))
}

// ModTime returns the modification time of the original file.
// Useful for caching purposes
// Returns zero time if the file is not in the bundle
func ModTime(file string) (t time.Time) {
	if f, ok := staticFiles[file]; ok {
		t = f.mtime
	}
	return
}

// Hash returns the hex-encoded SHA256 hash of the original file
// Used for the Etag, and useful for caching
// Returns an empty string if the file is not in the bundle
func Hash(file string) (s string) {
	if f, ok := staticFiles[file]; ok {
		s = f.hash
	}
	return
}
